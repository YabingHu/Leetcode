#74. Search a 2D Matrix
#Time=O(log(m*n)), space=O(1)
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m=len(matrix)
        if m==0: return False
        n=len(matrix[0])
        if n==0: return False
        if target<matrix[0][0] or target>matrix[m-1][n-1]:return False
        left=0
        right=m*n-1
        while left <= right:
            mid=left+(right-left)//2
            if matrix[mid//n][mid %n]==target:
                return True
            elif matrix[mid//n][mid%n]< target: left=mid+1
            else: right=mid-1
        return False
        
    
#378. Kth Smallest Element in a Sorted Matrix
#Time=O(nlgn*lgX),X is the difference between the maximum and minimum, space=O(1)
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        left=matrix[0][0]
        right=matrix[-1][-1]
        while left <= right:
            mid=left+(right-left)//2
            cnt=0
            for i in range(len(matrix)):
                cnt+=bisect.bisect_right(matrix[i], mid)
            if cnt<k:
                left=mid+1
            else:
                right=mid-1
        return left
            
#668. Kth Smallest Number in Multiplication Table
#Time=O(m*log(mn)), space=O(1)
class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:
        left=0
        right=m*n
        while left <= right:
            cnt=0
            mid=left+(right-left)//2
            for i in range(1,m+1):
                cnt+=n if mid > n*i else mid//i
            if cnt < k:
                left=mid+1
            else: right=mid-1
        return left

#778. Swim in Rising Water
#Time = O( n^2*log(n^2)),Space = O(n^2)
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n=len(grid)
        left=grid[0][0]
        right=n*n-1
        while left <= right:
            mid=left+(right-left)//2
            if self.helper(grid,mid):
                right=mid-1
            else:left=mid+1
        return left
        
    def helper(self,grid,mid):
        q=[(0,0)]
        visited=set((0,0))
        n=len(grid)
        while q:
            x,y=q.pop(0)
            if grid[x][y]<=mid:
                if x==n-1 and y==n-1: return True
                for i,j in [(0,1),(0,-1),(1,0),(-1,0)]:
                    if x+i<0 or x+i>=n or y+j<0 or y+j>=n or (x+i,y+j) in visited: continue
                    q.append((x+i,j+y))
                    visited.add((x+i,j+y))
        return False

#174. Dungeon Game
#Time=O(m*n), space=O(m*n)
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m=len(dungeon)
        if m==0: return 0
        n=len(dungeon[0])
        if n==0: return 0
        dp=[[float('Inf')]*(n+1) for _ in range(m+1)]
        dp[m][n-1]=1
        dp[m-1][n]=1
        for i in range(m-1,-1,-1):
            for j in range(n-1,-1,-1):
                dp[i][j]=max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j])
        return dp[0][0]
    
#875. Koko Eating Bananas
#Time=O(NlogW), N is number of piles and W is 1e9,space=O(1)
class Solution:
    def minEatingSpeed(self, piles: List[int], H: int) -> int:
        left=1
        right=1e9
        while left <= right:
            mid=left+(right-left)//2
            cnt=0
            for p in piles:
                cnt+=math.ceil(p/mid)
            if cnt>H:
                left=mid+1
            else:
                right=mid-1
        return int(left)
